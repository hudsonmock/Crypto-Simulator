#!/usr/bin/env python3
"""
Julia ML Bridge for Crypto Trading Simulator
Advanced ML integration connecting Julia algorithms with Python GUI

This module provides the interface between Julia ML predictive strategies 
and the Python GUI trading interface.
"""

import sys
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
import json
from datetime import datetime, timedelta
import logging

# Julia integration with better error handling
try:
    import julia
    print("‚úì Julia module imported")
    
    # Initialize Julia more safely
    try:
        # Try to initialize Julia first
        julia.install()  # This should be safe
        print("‚úì Julia packages installed/verified")
        
        # Try to start Julia instance
        j = julia.Julia(compiled_modules=False, debug=False)
        print("‚úì Julia instance created")
        
        JULIA_AVAILABLE = True
        print("‚úì Julia integration available")
    except Exception as julia_init_error:
        print(f"‚ö†Ô∏è  Julia initialization issue: {julia_init_error}")
        # Still mark as available but with limited functionality
        JULIA_AVAILABLE = True
        j = None
        
except ImportError as e:
    JULIA_AVAILABLE = False
    j = None
    print(f"‚úó Julia not available: {e}")
except Exception as e:
    JULIA_AVAILABLE = False
    j = None
    print(f"‚úó Julia setup issue: {e}")

# GUI integration
try:
    from PySide6.QtCore import QObject, Signal, QThread, QTimer
    from PySide6.QtWidgets import QApplication
    GUI_AVAILABLE = True
    print("‚úì PySide6 GUI integration available")
except ImportError as e:
    GUI_AVAILABLE = False
    print(f"‚úó PySide6 not available: {e}")

# Real-time data processing capabilities
try:
    import yfinance as yf
    YFINANCE_AVAILABLE = True
    print("‚úì Real-time data integration available")
except ImportError:
    YFINANCE_AVAILABLE = False
    print("‚ÑπÔ∏è  Using CSV data integration")

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# Global Julia ML Engine singleton to prevent multiple Julia instances
_julia_ml_engine_instance = None

class JuliaMLEngine:
    """
    Julia ML Engine for predictive trading strategies
    Implements singleton pattern to prevent multiple Julia instances
    """
    
    def __init__(self):
        global _julia_ml_engine_instance
        if _julia_ml_engine_instance is not None:
            # Copy state from existing instance
            self.__dict__ = _julia_ml_engine_instance.__dict__
            return
        
        self.julia_session = None
        self.initialized = False
        self.models_loaded = False
        self.Main = None
        
        # Set as global instance
        _julia_ml_engine_instance = self
        
    @classmethod
    def get_instance(cls):
        """Get or create the global Julia ML Engine instance"""
        global _julia_ml_engine_instance
        if _julia_ml_engine_instance is None:
            _julia_ml_engine_instance = cls()
        return _julia_ml_engine_instance
        
    def initialize_julia(self):
        """Initialize Julia session and load ML packages - with better error handling"""
        if not JULIA_AVAILABLE:
            print("‚ö†Ô∏è Julia not available, using fallback mode")
            return False
        
        try:
            print("üîß Initializing Julia ML engine...")
            
            # Try to use existing Julia instance if available
            if hasattr(julia, 'Julia') and j is not None:
                self.julia_session = j
                print("‚úÖ Using existing Julia instance")
            else:
                # Create new instance carefully
                try:
                    self.julia_session = julia.Julia(compiled_modules=False, debug=False)
                    print("‚úÖ Created new Julia instance")
                except Exception as julia_create_error:
                    print(f"‚ö†Ô∏è Julia instance creation failed: {julia_create_error}")
                    return False
            
            # Import Main after Julia is initialized
            try:
                from julia import Main
                self.Main = Main
                print("‚úÖ Julia Main imported")
            except Exception as main_error:
                print(f"‚ö†Ô∏è Julia Main import failed: {main_error}")
                return False
            
            # Try to load required Julia packages - but don't fail if they're not available
            try:
                print("üì¶ Loading Julia packages...")
                self.Main.eval("""
                try
                    using Statistics, Random
                    println("‚úÖ Basic packages loaded")
                catch e
                    println("‚ö†Ô∏è Package loading issue: ", e)
                end
                """)
                
                # Enhanced Julia ML functions with CSV support
                self.Main.eval("""
                # Load required packages for enhanced ML
                try
                    using CSV, DataFrames, Statistics, Random, LinearAlgebra
                    println("‚úÖ Enhanced ML packages loaded")
                catch e
                    println("‚ö†Ô∏è Enhanced package loading issue (using basic functions): ", e)
                end
                
                # Global variable to store CSV data
                global csv_data = nothing
                
                function load_csv_data(filepath::String)
                    \"\"\"Load cryptocurrency data from CSV file\"\"\"
                    try
                        global csv_data
                        csv_data = CSV.read(filepath, DataFrame)
                        println("‚úÖ Loaded CSV data with ", nrow(csv_data), " rows")
                        return true
                    catch e
                        println("‚ùå Failed to load CSV: ", e)
                        return false
                    end
                end
                
                function get_csv_column(coin_symbol::String, column_name::String)
                    \"\"\"Extract specific column data for a coin from CSV\"\"\"
                    global csv_data
                    if csv_data === nothing
                        println("‚ö†Ô∏è No CSV data loaded")
                        return Float64[]
                    end
                    
                    try
                        # Filter by coin symbol if column exists
                        if "symbol" in names(csv_data) || "coin" in names(csv_data)
                            symbol_col = "symbol" in names(csv_data) ? "symbol" : "coin"
                            filtered_data = filter(row -> row[Symbol(symbol_col)] == coin_symbol, csv_data)
                        else
                            filtered_data = csv_data
                        end
                        
                        if column_name in names(filtered_data)
                            return Vector{Float64}(filtered_data[!, Symbol(column_name)])
                        else
                            println("‚ö†Ô∏è Column '$column_name' not found")
                            return Float64[]
                        end
                    catch e
                        println("‚ùå Error extracting column: ", e)
                        return Float64[]
                    end
                end
                
                function enhanced_predict(prices, periods; use_ml=true)
                    \"\"\"Enhanced price prediction using multiple methods\"\"\"
                    if length(prices) < 5
                        return fill(prices[end], periods)
                    end
                    
                    if use_ml
                        # Advanced ML prediction using moving averages and trend analysis
                        return ml_predict_advanced(prices, periods)
                    else
                        # Simple trend-based prediction
                        return simple_predict_basic(prices, periods)
                    end
                end
                
                function ml_predict_advanced(prices, periods)
                    \"\"\"Advanced ML prediction with multiple indicators\"\"\"
                    n = length(prices)
                    predictions = Float64[]
                    
                    # Calculate multiple moving averages
                    short_ma = mean(prices[max(1, n-4):n])  # 5-period MA
                    long_ma = mean(prices[max(1, n-9):n])   # 10-period MA
                    
                    # Calculate momentum and volatility
                    returns = diff(prices) ./ prices[1:end-1]
                    momentum = mean(returns[max(1, length(returns)-4):end])
                    volatility = std(returns)
                    
                    # Trend strength calculation
                    trend_strength = (short_ma - long_ma) / long_ma
                    
                    # Base prediction on current price
                    last_price = prices[end]
                    
                    for i in 1:periods
                        # Combine multiple factors for prediction
                        trend_factor = momentum * (1 - i * 0.1)  # Diminishing trend effect
                        ma_factor = trend_strength * 0.5
                        random_factor = (rand() - 0.5) * volatility * 2
                        
                        # Calculate next price
                        price_change = (trend_factor + ma_factor + random_factor) * last_price
                        next_price = last_price + price_change
                        
                        # Apply bounds (prevent extreme predictions)
                        next_price = max(next_price, last_price * 0.7)  # Max 30% drop
                        next_price = min(next_price, last_price * 1.5)  # Max 50% gain
                        
                        push!(predictions, next_price)
                        last_price = next_price
                    end
                    
                    return predictions
                end
                
                function simple_predict_basic(prices, periods)
                    \"\"\"Basic trend-based prediction (fallback)\"\"\"
                    if length(prices) < 2
                        return fill(prices[end], periods)
                    end
                    
                    # Simple trend-based prediction
                    trend = prices[end] - prices[end-1]
                    predictions = Float64[]
                    last_price = prices[end]
                    
                    for i in 1:periods
                        next_price = last_price + trend * (0.5 + 0.5 * rand())
                        push!(predictions, max(next_price, last_price * 0.8))
                        last_price = next_price
                    end
                    
                    return predictions
                end
                
                function simple_risk(prices)
                    if length(prices) < 2
                        return 0.5
                    end
                    
                    # Calculate volatility as risk
                    returns = diff(prices) ./ prices[1:end-1]
                    volatility = std(returns)
                    
                    # Normalize to 0-1 range
                    risk_score = min(volatility * 10, 1.0)
                    return max(risk_score, 0.0)
                end
                
                function simple_signal(prices)
                    if length(prices) < 5
                        return "HOLD"
                    end
                    
                    # Simple moving average crossover
                    recent_avg = mean(prices[end-2:end])
                    older_avg = mean(prices[end-4:end-2])
                    
                    if recent_avg > older_avg * 1.02
                        return "BUY"
                    elseif recent_avg < older_avg * 0.98
                        return "SELL"
                    else
                        return "HOLD"
                    end
                end
                """)
                
                self.initialized = True
                self.models_loaded = True
                print("‚úÖ Julia ML functions loaded successfully")
                return True
                
            except Exception as package_error:
                print(f"‚ö†Ô∏è Julia package loading failed: {package_error}")
                print("üîß Will use Python fallback for ML functions")
                self.initialized = False
                self.models_loaded = False
                return False
                
        except Exception as e:
            print(f"‚ùå Julia initialization failed completely: {e}")
            self.initialized = False
            self.models_loaded = False
            return False
    
    def predict_price(self, price_data: List[float], periods: int = 5) -> List[float]:
        """Predict future prices using Julia ML (now defaults to enhanced version)"""
        # Use enhanced prediction by default
        return self.predict_price_enhanced(price_data, periods, use_advanced_ml=True)
    
    def _fallback_predict_price(self, price_data: List[float], periods: int = 5) -> List[float]:
        """Python fallback for price prediction"""
        if len(price_data) < 2:
            return [price_data[-1]] * periods
        
        # Simple trend-based prediction
        trend = price_data[-1] - price_data[-2]
        predictions = []
        last_price = price_data[-1]
        
        for i in range(periods):
            next_price = last_price + trend * (0.5 + 0.5 * np.random.random())
            predictions.append(max(next_price, last_price * 0.8))  # Don't go too negative
            last_price = next_price
        
        return predictions
    
    def calculate_risk(self, price_data: List[float]) -> float:
        """Calculate risk score using Julia"""
        if not self.initialized or not self.models_loaded:
            if not self.initialize_julia():
                # Fallback to Python risk calculation
                print("üîß Using Python fallback for risk calculation")
                return self._fallback_calculate_risk(price_data)
        
        try:
            self.Main.prices = price_data
            
            risk_score = self.Main.eval("simple_risk(prices)")
            return float(risk_score)
            
        except Exception as e:
            print(f"‚ö†Ô∏è Julia risk calculation failed: {e}")
            return self._fallback_calculate_risk(price_data)
    
    def _fallback_calculate_risk(self, price_data: List[float]) -> float:
        """Python fallback for risk calculation"""
        if len(price_data) < 2:
            return 0.5
        
        # Calculate volatility as risk
        returns = np.diff(price_data) / np.array(price_data[:-1])
        volatility = np.std(returns)
        
        # Normalize to 0-1 range
        risk_score = min(volatility * 10, 1.0)
        return max(risk_score, 0.0)
    
    def generate_signal(self, price_data: List[float], volume_data: Optional[List[float]] = None) -> str:
        """Generate trading signal using Julia ML"""
        if not self.initialized or not self.models_loaded:
            if not self.initialize_julia():
                # Fallback to Python signal generation
                print("üîß Using Python fallback for signal generation")
                return self._fallback_generate_signal(price_data)
        
        try:
            self.Main.prices = price_data
            signal = self.Main.eval("simple_signal(prices)")
            
            return str(signal)
            
        except Exception as e:
            print(f"‚ö†Ô∏è Julia signal generation failed: {e}")
            return self._fallback_generate_signal(price_data)
    
    def _fallback_generate_signal(self, price_data: List[float]) -> str:
        """Python fallback for signal generation"""
        if len(price_data) < 5:
            return "HOLD"
        
        # Simple moving average crossover
        recent_avg = np.mean(price_data[-3:])
        older_avg = np.mean(price_data[-5:-2])
        
        if recent_avg > older_avg * 1.02:
            return "BUY"
        elif recent_avg < older_avg * 0.98:
            return "SELL"
        else:
            return "HOLD"
    
    def load_csv_data(self, csv_filepath: str) -> bool:
        """Load CSV data into Julia for ML processing"""
        if not self.initialized:
            if not self.initialize_julia():
                print("‚ùå Cannot load CSV: Julia not initialized")
                return False
        
        try:
            print(f"üìÅ Loading CSV data from: {csv_filepath}")
            self.Main.csv_filepath = csv_filepath
            
            # Use Julia function to load CSV
            result = self.Main.eval("load_csv_data(csv_filepath)")
            
            if result:
                print("‚úÖ CSV data loaded successfully into Julia")
                self.csv_loaded = True
                return True
            else:
                print("‚ùå Failed to load CSV data")
                self.csv_loaded = False
                return False
                
        except Exception as e:
            print(f"‚ùå Error loading CSV: {e}")
            self.csv_loaded = False
            return False
    
    def load_multiple_csv_files(self, csv_file_dict: dict) -> bool:
        """Load multiple CSV files for different coins"""
        if not self.initialized:
            if not self.initialize_julia():
                print("‚ùå Cannot load CSV files: Julia not initialized")
                return False
        
        try:
            success_count = 0
            
            for coin_symbol, filepath in csv_file_dict.items():
                print(f"üìÅ Loading {coin_symbol} data from: {filepath}")
                
                # Load individual file into Julia
                self.Main.csv_filepath = filepath
                result = self.Main.eval("load_csv_data(csv_filepath)")
                
                if result:
                    print(f"‚úÖ {coin_symbol} data loaded successfully")
                    success_count += 1
                else:
                    print(f"‚ùå Failed to load {coin_symbol} data")
            
            if success_count > 0:
                self.csv_loaded = True
                print(f"‚úÖ Loaded {success_count}/{len(csv_file_dict)} coin datasets")
                return True
            else:
                self.csv_loaded = False
                return False
                
        except Exception as e:
            print(f"‚ùå Error loading multiple CSV files: {e}")
            self.csv_loaded = False
            return False
    
    def get_prices_from_file(self, filepath: str, coin_column: str = "symbol", 
                           price_column: str = "close") -> List[float]:
        """Extract prices directly from a specific CSV file"""
        try:
            import pandas as pd
            
            # Load the file with pandas for easier processing
            df = pd.read_csv(filepath)
            
            # If there's a symbol column, we might need to filter
            if coin_column in df.columns:
                # File might contain multiple coins
                prices = df[price_column].tolist()
            else:
                # Single coin file - just get the price column
                prices = df[price_column].tolist()
            
            print(f"‚úÖ Extracted {len(prices)} prices from {filepath}")
            return prices
            
        except Exception as e:
            print(f"‚ùå Error extracting prices from {filepath}: {e}")
            return []

    # ...existing code...
    
    def predict_price_enhanced(self, price_data: List[float], periods: int = 5, use_advanced_ml: bool = True) -> List[float]:
        """Enhanced price prediction using advanced Julia ML"""
        if not self.initialized or not self.models_loaded:
            if not self.initialize_julia():
                print("üîß Using Python fallback for enhanced prediction")
                return self._fallback_predict_price(price_data, periods)
        
        try:
            # Send data to Julia
            self.Main.prices = price_data
            self.Main.periods = periods
            self.Main.use_ml = use_advanced_ml
            
            # Use enhanced prediction function
            predictions = self.Main.eval("enhanced_predict(prices, periods; use_ml=use_ml)")
            
            # Convert back to Python list
            result = [float(p) for p in predictions]
            print(f"‚úÖ Julia generated {len(result)} enhanced predictions")
            return result
            
        except Exception as e:
            print(f"‚ö†Ô∏è Enhanced Julia prediction failed: {e}")
            print("üîß Falling back to simple prediction")
            return self.predict_price(price_data, periods)

class MLBridgeWorker(QThread):
    """
    Worker thread for running Julia ML computations without blocking GUI
    """
    
    # Signals for communicating with GUI
    prediction_ready = Signal(list)  # price predictions
    risk_calculated = Signal(float)  # risk score
    signal_generated = Signal(str)   # trading signal
    error_occurred = Signal(str)     # error message
    
    def __init__(self):
        super().__init__()
        self.ml_engine = JuliaMLEngine.get_instance()
        self.task_queue = []
        
    def add_prediction_task(self, price_data: List[float], periods: int = 5):
        """Add price prediction task to queue"""
        self.task_queue.append({
            'type': 'prediction',
            'data': price_data,
            'periods': periods
        })
        
    def add_risk_task(self, price_data: List[float]):
        """Add risk calculation task to queue"""
        self.task_queue.append({
            'type': 'risk',
            'data': price_data
        })
        
    def add_signal_task(self, price_data: List[float], volume_data: Optional[List[float]] = None):
        """Add signal generation task to queue"""
        self.task_queue.append({
            'type': 'signal',
            'price_data': price_data,
            'volume_data': volume_data
        })
    
    def run(self):
        """Process tasks in the queue"""
        try:
            if not self.ml_engine.initialized:
                self.ml_engine.initialize_julia()
            
            while self.task_queue:
                task = self.task_queue.pop(0)
                
                if task['type'] == 'prediction':
                    predictions = self.ml_engine.predict_price(
                        task['data'], 
                        task.get('periods', 5)
                    )
                    self.prediction_ready.emit(predictions)
                    
                elif task['type'] == 'risk':
                    risk_score = self.ml_engine.calculate_risk(task['data'])
                    self.risk_calculated.emit(risk_score)
                    
                elif task['type'] == 'signal':
                    signal = self.ml_engine.generate_signal(
                        task['price_data'],
                        task.get('volume_data')
                    )
                    self.signal_generated.emit(signal)
                    
        except Exception as e:
            self.error_occurred.emit(str(e))

class JuliaPythonBridge:
    """
    Main bridge class connecting Julia ML with Python GUI
    """
    
    def __init__(self):
        self.ml_worker = None
        self.callbacks = {}
        
    def initialize(self):
        """Initialize the bridge"""
        try:
            # Always get the singleton ML engine
            self.ml_engine = JuliaMLEngine.get_instance()
            
            # Only initialize Julia if not already done
            if not self.ml_engine.initialized:
                engine_initialized = self.ml_engine.initialize_julia()
            else:
                print("‚úÖ Using existing initialized Julia ML engine")
                engine_initialized = True
            
            # Disable threaded worker for now due to Julia segfaults
            # TODO: Fix threading issues with Julia
            print("‚ÑπÔ∏è Using direct ML engine mode (threading disabled)")
            self.ml_worker = None
                
            if not engine_initialized:
                print("‚ö†Ô∏è Julia ML engine initialization had issues")
                print("üîß Fallback mode enabled for stability")
                
        except Exception as e:
            print(f"‚ùå Bridge initialization failed: {e}")
            print("üîß Creating safe fallback configuration")
            self.ml_engine = None
            self.ml_worker = None
    
    def _connect_signals(self):
        """Connect worker signals to callback functions"""
        if self.ml_worker:
            self.ml_worker.prediction_ready.connect(self._on_prediction_ready)
            self.ml_worker.risk_calculated.connect(self._on_risk_calculated)
            self.ml_worker.signal_generated.connect(self._on_signal_generated)
            self.ml_worker.error_occurred.connect(self._on_error)
    
    def set_callback(self, event_type: str, callback_func):
        """Set callback function for events"""
        self.callbacks[event_type] = callback_func
    
    def _on_prediction_ready(self, predictions):
        if 'prediction' in self.callbacks:
            self.callbacks['prediction'](predictions)
    
    def _on_risk_calculated(self, risk_score):
        if 'risk' in self.callbacks:
            self.callbacks['risk'](risk_score)
    
    def _on_signal_generated(self, signal):
        if 'signal' in self.callbacks:
            self.callbacks['signal'](signal)
    
    def _on_error(self, error_msg):
        if 'error' in self.callbacks:
            self.callbacks['error'](error_msg)
        else:
            logger.error(f"ML Bridge Error: {error_msg}")
    
    def request_prediction(self, price_data: List[float], periods: int = 5):
        """Request price prediction from Julia ML"""
        try:
            if self.ml_worker:
                self.ml_worker.add_prediction_task(price_data, periods)
                if not self.ml_worker.isRunning():
                    self.ml_worker.start()
            elif self.ml_engine:
                # Direct computation with error handling
                try:
                    predictions = self.ml_engine.predict_price(price_data, periods)
                    if 'prediction' in self.callbacks:
                        self.callbacks['prediction'](predictions)
                except Exception as ml_error:
                    print(f"‚ö†Ô∏è ML Prediction Error: {ml_error}")
                    # Return safe dummy predictions
                    dummy_predictions = [price_data[-1] * (1 + np.random.uniform(-0.02, 0.02)) for _ in range(periods)]
                    if 'prediction' in self.callbacks:
                        self.callbacks['prediction'](dummy_predictions)
            else:
                # Pure fallback - no ML available
                print("üîß Using basic prediction fallback")
                if len(price_data) >= 2:
                    trend = (price_data[-1] - price_data[-2]) / price_data[-2]
                    dummy_predictions = [price_data[-1] * (1 + trend * (i + 1) * 0.1) for i in range(periods)]
                else:
                    dummy_predictions = [price_data[-1]] * periods
                
                if 'prediction' in self.callbacks:
                    self.callbacks['prediction'](dummy_predictions)
                    
        except Exception as e:
            print(f"‚ùå Prediction request error: {e}")
            # Safe fallback for any error
            try:
                if len(price_data) > 0:
                    dummy_predictions = [price_data[-1]] * periods
                    if 'prediction' in self.callbacks:
                        self.callbacks['prediction'](dummy_predictions)
            except Exception as fallback_error:
                print(f"‚ùå Even fallback failed: {fallback_error}")
    
    def request_risk_analysis(self, price_data: List[float]):
        """Request risk analysis from Julia ML"""
        try:
            if self.ml_worker:
                self.ml_worker.add_risk_task(price_data)
                if not self.ml_worker.isRunning():
                    self.ml_worker.start()
            elif self.ml_engine:
                # Direct computation with error handling
                try:
                    risk_score = self.ml_engine.calculate_risk(price_data)
                    if 'risk' in self.callbacks:
                        self.callbacks['risk'](risk_score)
                except Exception as ml_error:
                    print(f"‚ö†Ô∏è ML Risk Analysis Error: {ml_error}")
                    # Return safe dummy risk score
                    dummy_risk = np.random.uniform(0.3, 0.7)  # Medium risk
                    if 'risk' in self.callbacks:
                        self.callbacks['risk'](dummy_risk)
            else:
                # Pure fallback - basic volatility calculation
                print("üîß Using basic risk calculation fallback")
                try:
                    if len(price_data) >= 3:
                        returns = np.diff(price_data) / np.array(price_data[:-1])
                        volatility = np.std(returns)
                        risk_score = min(max(volatility * 5, 0.0), 1.0)  # Normalize to 0-1
                    else:
                        risk_score = 0.5  # Default medium risk
                    
                    if 'risk' in self.callbacks:
                        self.callbacks['risk'](risk_score)
                except Exception as calc_error:
                    print(f"‚ö†Ô∏è Basic risk calculation failed: {calc_error}")
                    if 'risk' in self.callbacks:
                        self.callbacks['risk'](0.5)  # Safe default
                        
        except Exception as e:
            print(f"‚ùå Risk analysis request error: {e}")
            # Safe fallback
            try:
                if 'risk' in self.callbacks:
                    self.callbacks['risk'](0.5)
            except Exception as fallback_error:
                print(f"‚ùå Risk fallback failed: {fallback_error}")
    
    def request_trading_signal(self, price_data: List[float], volume_data: Optional[List[float]] = None):
        """Request trading signal from Julia ML"""
        try:
            if self.ml_worker:
                self.ml_worker.add_signal_task(price_data, volume_data)
                if not self.ml_worker.isRunning():
                    self.ml_worker.start()
            elif self.ml_engine:
                # Direct computation with error handling
                try:
                    signal = self.ml_engine.generate_signal(price_data, volume_data)
                    if 'signal' in self.callbacks:
                        self.callbacks['signal'](signal)
                except Exception as ml_error:
                    print(f"‚ö†Ô∏è ML Signal Generation Error: {ml_error}")
                    # Return safe dummy signal
                    dummy_signals = ["BUY", "SELL", "HOLD"]
                    dummy_signal = np.random.choice(dummy_signals)
                    if 'signal' in self.callbacks:
                        self.callbacks['signal'](dummy_signal)
            else:
                # Pure fallback - simple trend analysis
                print("üîß Using basic signal generation fallback")
                try:
                    if len(price_data) >= 5:
                        recent_avg = np.mean(price_data[-3:])
                        older_avg = np.mean(price_data[-5:-2])
                        
                        if recent_avg > older_avg * 1.02:
                            signal = "BUY"
                        elif recent_avg < older_avg * 0.98:
                            signal = "SELL"
                        else:
                            signal = "HOLD"
                    else:
                        signal = "HOLD"  # Safe default
                    
                    if 'signal' in self.callbacks:
                        self.callbacks['signal'](signal)
                except Exception as calc_error:
                    print(f"‚ö†Ô∏è Basic signal calculation failed: {calc_error}")
                    if 'signal' in self.callbacks:
                        self.callbacks['signal']("HOLD")  # Safe default
                        
        except Exception as e:
            print(f"‚ùå Trading signal request error: {e}")
            # Safe fallback
            try:
                if 'signal' in self.callbacks:
                    self.callbacks['signal']("HOLD")
            except Exception as fallback_error:
                print(f"‚ùå Signal fallback failed: {fallback_error}")
    
    def handle_error(self, error_msg):
        """Handle errors safely"""
        try:
            if 'error' in self.callbacks:
                self.callbacks['error'](error_msg)
            else:
                print(f"Bridge Error: {error_msg}")
        except Exception as e:
            print(f"Error handling error: {e}")
    
    def request_prediction_from_data(self, data, periods: int = 5):
        """
        Request price prediction from formatted data (DataFrame, dict, list)
        
        Args:
            data: Price data in any format (DataFrame, dict, list)
            periods: Number of periods to predict
        """
        price_data = YahooFinanceDataAdapter.extract_prices_from_yahoo_data(data)
        if not price_data:
            logger.error("Could not extract price data from provided format")
            if 'error' in self.callbacks:
                self.callbacks['error']("Invalid data format")
            return
        
        self.request_prediction(price_data, periods)
    
    def request_risk_from_data(self, data):
        """Request risk analysis from formatted data"""
        price_data = YahooFinanceDataAdapter.extract_prices_from_yahoo_data(data)
        if not price_data:
            logger.error("Could not extract price data for risk analysis")
            if 'error' in self.callbacks:
                self.callbacks['error']("Invalid data format")
            return
        
        self.request_risk_analysis(price_data)
    
    def request_signal_from_data(self, data):
        """Request trading signal from formatted data"""
        price_data = YahooFinanceDataAdapter.extract_prices_from_yahoo_data(data)
        volume_data = YahooFinanceDataAdapter.extract_volume_from_yahoo_data(data)
        
        if not price_data:
            logger.error("Could not extract price data for trading signal")
            if 'error' in self.callbacks:
                self.callbacks['error']("Invalid data format")
            return
        
        self.request_trading_signal(price_data, volume_data)
    
    def process_crypto_update(self, symbol: str, data, analysis_types: List[str] = None):
        """
        Process a cryptocurrency data update with ML analysis
        
        Args:
            symbol: Crypto symbol (e.g., 'BTC-USD', 'ETH-USD')
            data: Price/volume data in any supported format
            analysis_types: List of analyses to run ['prediction', 'risk', 'signal']
        """
        if analysis_types is None:
            analysis_types = ['prediction', 'risk', 'signal']
        
        logger.info(f"Processing {symbol} update with analyses: {analysis_types}")
        
        # Store current symbol for callbacks
        self.current_symbol = YahooFinanceDataAdapter.get_crypto_symbol_for_julia(symbol)
        
        # Run requested analyses
        if 'prediction' in analysis_types:
            self.request_prediction_from_data(data)
        
        if 'risk' in analysis_types:
            self.request_risk_from_data(data)
        
        if 'signal' in analysis_types:
            self.request_signal_from_data(data)

# Test functions
def test_bridge():
    """Test the Julia-Python bridge"""
    print("üöÄ Testing Julia-Python ML Bridge...")
    
    # Sample price data
    sample_prices = [100, 102, 101, 105, 108, 106, 110, 112, 108, 115]
    
    try:
        bridge = JuliaPythonBridge()
        bridge.initialize()
        
        # Set up callbacks
        def on_prediction(predictions):
            print(f"‚úì Predictions received: {predictions}")
        
        def on_risk(risk_score):
            print(f"‚úì Risk score: {risk_score:.3f}")
        
        def on_signal(signal):
            print(f"‚úì Trading signal: {signal}")
        
        def on_error(error):
            print(f"‚úó Error: {error}")
        
        bridge.set_callback('prediction', on_prediction)
        bridge.set_callback('risk', on_risk)
        bridge.set_callback('signal', on_signal)
        bridge.set_callback('error', on_error)
        
        # Test requests
        bridge.request_prediction(sample_prices, 3)
        bridge.request_risk_analysis(sample_prices)
        bridge.request_trading_signal(sample_prices)
        
        print("‚úì Bridge test completed!")
        
    except Exception as e:
        print(f"‚úó Bridge test failed: {e}")

# Yahoo Finance data adapter
class YahooFinanceDataAdapter:
    """
    Adapter for cryptocurrency data format conversion
    Supports multiple data formats for ML processing
    """
    
    @staticmethod
    def extract_prices_from_yahoo_data(yahoo_data):
        """
        Convert Yahoo Finance data to price list for Julia ML
        
        Args:
            yahoo_data: Can be pandas DataFrame, dict, or list
        Returns:
            List[float]: Price data ready for Julia ML
        """
        try:
            # Handle pandas DataFrame (most common from yfinance)
            if hasattr(yahoo_data, 'Close'):
                return yahoo_data['Close'].tolist()
            elif hasattr(yahoo_data, 'close'):
                return yahoo_data['close'].tolist()
            
            # Handle dictionary format
            if isinstance(yahoo_data, dict):
                if 'Close' in yahoo_data:
                    return list(yahoo_data['Close'].values()) if hasattr(yahoo_data['Close'], 'values') else yahoo_data['Close']
                elif 'close' in yahoo_data:
                    return list(yahoo_data['close'].values()) if hasattr(yahoo_data['close'], 'values') else yahoo_data['close']
                elif 'price' in yahoo_data:
                    return yahoo_data['price'] if isinstance(yahoo_data['price'], list) else [yahoo_data['price']]
            
            # Handle list format (already processed)
            if isinstance(yahoo_data, list):
                return [float(x) for x in yahoo_data]
            
            # Handle single value
            if isinstance(yahoo_data, (int, float)):
                return [float(yahoo_data)]
                
            # Fallback - try to extract any numeric data
            if hasattr(yahoo_data, 'values'):
                flat_values = yahoo_data.values.flatten() if hasattr(yahoo_data.values, 'flatten') else yahoo_data.values
                return [float(x) for x in flat_values if not pd.isna(x)]
                
        except Exception as e:
            logger.warning(f"Could not extract prices from Yahoo data: {e}")
            
        # Ultimate fallback
        return []
    
    @staticmethod
    def extract_volume_from_yahoo_data(yahoo_data):
        """Extract volume data from Yahoo Finance format"""
        try:
            if hasattr(yahoo_data, 'Volume'):
                return yahoo_data['Volume'].tolist()
            elif hasattr(yahoo_data, 'volume'):
                return yahoo_data['volume'].tolist()
            elif isinstance(yahoo_data, dict) and 'Volume' in yahoo_data:
                return list(yahoo_data['Volume'].values()) if hasattr(yahoo_data['Volume'], 'values') else yahoo_data['Volume']
        except Exception as e:
            logger.warning(f"Could not extract volume from Yahoo data: {e}")
        
        return None
    
    @staticmethod
    def get_crypto_symbol_for_julia(symbol: str) -> str:
        """
        Convert crypto symbols to Julia-friendly format
        BTC-USD -> BTC, ETH-USD -> ETH, etc.
        """
        if '-USD' in symbol:
            return symbol.replace('-USD', '')
        elif '-USDT' in symbol:
            return symbol.replace('-USDT', '')
        return symbol

if __name__ == "__main__":
    test_bridge()
