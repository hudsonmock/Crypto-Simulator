#!/usr/bin/env python3
"""
Julia ML Bridge for Crypto Trading Simulator
Person E: Connecting Julia ML with Python GUI

This module provides the interface between Julia ML predictive strategies 
and the Python GUI trading interface.
"""

import sys
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
import json
from datetime import datetime, timedelta
import logging

# Julia integration with better error handling
try:
    import julia
    print("‚úì Julia module imported")
    
    # Initialize Julia more safely
    try:
        # Try to initialize Julia first
        julia.install()  # This should be safe
        print("‚úì Julia packages installed/verified")
        
        # Try to start Julia instance
        j = julia.Julia(compiled_modules=False, debug=False)
        print("‚úì Julia instance created")
        
        JULIA_AVAILABLE = True
        print("‚úì Julia integration available")
    except Exception as julia_init_error:
        print(f"‚ö†Ô∏è  Julia initialization issue: {julia_init_error}")
        # Still mark as available but with limited functionality
        JULIA_AVAILABLE = True
        j = None
        
except ImportError as e:
    JULIA_AVAILABLE = False
    j = None
    print(f"‚úó Julia not available: {e}")
except Exception as e:
    JULIA_AVAILABLE = False
    j = None
    print(f"‚úó Julia setup issue: {e}")

# GUI integration
try:
    from PySide6.QtCore import QObject, Signal, QThread, QTimer
    from PySide6.QtWidgets import QApplication
    GUI_AVAILABLE = True
    print("‚úì PySide6 GUI integration available")
except ImportError as e:
    GUI_AVAILABLE = False
    print(f"‚úó PySide6 not available: {e}")

# Yahoo Finance data compatibility
try:
    import yfinance as yf
    YFINANCE_AVAILABLE = True
    print("‚úì Yahoo Finance integration available")
except ImportError:
    YFINANCE_AVAILABLE = False
    print("‚ÑπÔ∏è  Yahoo Finance not installed (Person D will handle data)")

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# Global Julia ML Engine singleton to prevent multiple Julia instances
_julia_ml_engine_instance = None

class JuliaMLEngine:
    """
    Julia ML Engine for predictive trading strategies
    Implements singleton pattern to prevent multiple Julia instances
    """
    
    def __init__(self):
        global _julia_ml_engine_instance
        if _julia_ml_engine_instance is not None:
            # Copy state from existing instance
            self.__dict__ = _julia_ml_engine_instance.__dict__
            return
        
        self.julia_session = None
        self.initialized = False
        self.models_loaded = False
        self.Main = None
        
        # Set as global instance
        _julia_ml_engine_instance = self
        
    @classmethod
    def get_instance(cls):
        """Get or create the global Julia ML Engine instance"""
        global _julia_ml_engine_instance
        if _julia_ml_engine_instance is None:
            _julia_ml_engine_instance = cls()
        return _julia_ml_engine_instance
        
    def initialize_julia(self):
        """Initialize Julia session and load ML packages - with better error handling"""
        if not JULIA_AVAILABLE:
            print("‚ö†Ô∏è Julia not available, using fallback mode")
            return False
        
        try:
            print("üîß Initializing Julia ML engine...")
            
            # Try to use existing Julia instance if available
            if hasattr(julia, 'Julia') and j is not None:
                self.julia_session = j
                print("‚úÖ Using existing Julia instance")
            else:
                # Create new instance carefully
                try:
                    self.julia_session = julia.Julia(compiled_modules=False, debug=False)
                    print("‚úÖ Created new Julia instance")
                except Exception as julia_create_error:
                    print(f"‚ö†Ô∏è Julia instance creation failed: {julia_create_error}")
                    return False
            
            # Import Main after Julia is initialized
            try:
                from julia import Main
                self.Main = Main
                print("‚úÖ Julia Main imported")
            except Exception as main_error:
                print(f"‚ö†Ô∏è Julia Main import failed: {main_error}")
                return False
            
            # Try to load required Julia packages - but don't fail if they're not available
            try:
                print("üì¶ Loading Julia packages...")
                self.Main.eval("""
                try
                    using Statistics, Random
                    println("‚úÖ Basic packages loaded")
                catch e
                    println("‚ö†Ô∏è Package loading issue: ", e)
                end
                """)
                
                # Define simple prediction functions
                self.Main.eval("""
                function simple_predict(prices, periods)
                    if length(prices) < 2
                        return fill(prices[end], periods)
                    end
                    
                    # Simple trend-based prediction
                    trend = prices[end] - prices[end-1]
                    predictions = Float64[]
                    last_price = prices[end]
                    
                    for i in 1:periods
                        next_price = last_price + trend * (0.5 + 0.5 * rand())
                        push!(predictions, max(next_price, last_price * 0.8))  # Don't go too negative
                        last_price = next_price
                    end
                    
                    return predictions
                end
                
                function simple_risk(prices)
                    if length(prices) < 2
                        return 0.5
                    end
                    
                    # Calculate volatility as risk
                    returns = diff(prices) ./ prices[1:end-1]
                    volatility = std(returns)
                    
                    # Normalize to 0-1 range
                    risk_score = min(volatility * 10, 1.0)
                    return max(risk_score, 0.0)
                end
                
                function simple_signal(prices)
                    if length(prices) < 5
                        return "HOLD"
                    end
                    
                    # Simple moving average crossover
                    recent_avg = mean(prices[end-2:end])
                    older_avg = mean(prices[end-4:end-2])
                    
                    if recent_avg > older_avg * 1.02
                        return "BUY"
                    elseif recent_avg < older_avg * 0.98
                        return "SELL"
                    else
                        return "HOLD"
                    end
                end
                """)
                
                self.initialized = True
                self.models_loaded = True
                print("‚úÖ Julia ML functions loaded successfully")
                return True
                
            except Exception as package_error:
                print(f"‚ö†Ô∏è Julia package loading failed: {package_error}")
                print("üîß Will use Python fallback for ML functions")
                self.initialized = False
                self.models_loaded = False
                return False
                
        except Exception as e:
            print(f"‚ùå Julia initialization failed completely: {e}")
            self.initialized = False
            self.models_loaded = False
            return False
    
    def predict_price(self, price_data: List[float], periods: int = 5) -> List[float]:
        """Predict future prices using Julia ML"""
        if not self.initialized or not self.models_loaded:
            if not self.initialize_julia():
                # Fallback to Python prediction
                print("üîß Using Python fallback for price prediction")
                return self._fallback_predict_price(price_data, periods)
        
        try:
            # Convert to Julia array
            self.Main.prices = price_data
            self.Main.periods = periods
            
            # Get predictions using our defined function
            predictions = self.Main.eval("simple_predict(prices, periods)")
            
            # Convert back to Python list
            return [float(p) for p in predictions]
            
        except Exception as e:
            print(f"‚ö†Ô∏è Julia price prediction failed: {e}")
            return self._fallback_predict_price(price_data, periods)
    
    def _fallback_predict_price(self, price_data: List[float], periods: int = 5) -> List[float]:
        """Python fallback for price prediction"""
        if len(price_data) < 2:
            return [price_data[-1]] * periods
        
        # Simple trend-based prediction
        trend = price_data[-1] - price_data[-2]
        predictions = []
        last_price = price_data[-1]
        
        for i in range(periods):
            next_price = last_price + trend * (0.5 + 0.5 * np.random.random())
            predictions.append(max(next_price, last_price * 0.8))  # Don't go too negative
            last_price = next_price
        
        return predictions
    
    def calculate_risk(self, price_data: List[float]) -> float:
        """Calculate risk score using Julia"""
        if not self.initialized or not self.models_loaded:
            if not self.initialize_julia():
                # Fallback to Python risk calculation
                print("üîß Using Python fallback for risk calculation")
                return self._fallback_calculate_risk(price_data)
        
        try:
            self.Main.prices = price_data
            
            risk_score = self.Main.eval("simple_risk(prices)")
            return float(risk_score)
            
        except Exception as e:
            print(f"‚ö†Ô∏è Julia risk calculation failed: {e}")
            return self._fallback_calculate_risk(price_data)
    
    def _fallback_calculate_risk(self, price_data: List[float]) -> float:
        """Python fallback for risk calculation"""
        if len(price_data) < 2:
            return 0.5
        
        # Calculate volatility as risk
        returns = np.diff(price_data) / np.array(price_data[:-1])
        volatility = np.std(returns)
        
        # Normalize to 0-1 range
        risk_score = min(volatility * 10, 1.0)
        return max(risk_score, 0.0)
    
    def generate_signal(self, price_data: List[float], volume_data: Optional[List[float]] = None) -> str:
        """Generate trading signal using Julia ML"""
        if not self.initialized or not self.models_loaded:
            if not self.initialize_julia():
                # Fallback to Python signal generation
                print("üîß Using Python fallback for signal generation")
                return self._fallback_generate_signal(price_data)
        
        try:
            self.Main.prices = price_data
            signal = self.Main.eval("simple_signal(prices)")
            
            return str(signal)
            
        except Exception as e:
            print(f"‚ö†Ô∏è Julia signal generation failed: {e}")
            return self._fallback_generate_signal(price_data)
    
    def _fallback_generate_signal(self, price_data: List[float]) -> str:
        """Python fallback for signal generation"""
        if len(price_data) < 5:
            return "HOLD"
        
        # Simple moving average crossover
        recent_avg = np.mean(price_data[-3:])
        older_avg = np.mean(price_data[-5:-2])
        
        if recent_avg > older_avg * 1.02:
            return "BUY"
        elif recent_avg < older_avg * 0.98:
            return "SELL"
        else:
            return "HOLD"

class MLBridgeWorker(QThread):
    """
    Worker thread for running Julia ML computations without blocking GUI
    """
    
    # Signals for communicating with GUI
    prediction_ready = Signal(list)  # price predictions
    risk_calculated = Signal(float)  # risk score
    signal_generated = Signal(str)   # trading signal
    error_occurred = Signal(str)     # error message
    
    def __init__(self):
        super().__init__()
        self.ml_engine = JuliaMLEngine.get_instance()
        self.task_queue = []
        
    def add_prediction_task(self, price_data: List[float], periods: int = 5):
        """Add price prediction task to queue"""
        self.task_queue.append({
            'type': 'prediction',
            'data': price_data,
            'periods': periods
        })
        
    def add_risk_task(self, price_data: List[float]):
        """Add risk calculation task to queue"""
        self.task_queue.append({
            'type': 'risk',
            'data': price_data
        })
        
    def add_signal_task(self, price_data: List[float], volume_data: Optional[List[float]] = None):
        """Add signal generation task to queue"""
        self.task_queue.append({
            'type': 'signal',
            'price_data': price_data,
            'volume_data': volume_data
        })
    
    def run(self):
        """Process tasks in the queue"""
        try:
            if not self.ml_engine.initialized:
                self.ml_engine.initialize_julia()
            
            while self.task_queue:
                task = self.task_queue.pop(0)
                
                if task['type'] == 'prediction':
                    predictions = self.ml_engine.predict_price(
                        task['data'], 
                        task.get('periods', 5)
                    )
                    self.prediction_ready.emit(predictions)
                    
                elif task['type'] == 'risk':
                    risk_score = self.ml_engine.calculate_risk(task['data'])
                    self.risk_calculated.emit(risk_score)
                    
                elif task['type'] == 'signal':
                    signal = self.ml_engine.generate_signal(
                        task['price_data'],
                        task.get('volume_data')
                    )
                    self.signal_generated.emit(signal)
                    
        except Exception as e:
            self.error_occurred.emit(str(e))

class JuliaPythonBridge:
    """
    Main bridge class connecting Julia ML with Python GUI
    """
    
    def __init__(self):
        self.ml_worker = None
        self.callbacks = {}
        
    def initialize(self):
        """Initialize the bridge"""
        try:
            # Always get the singleton ML engine
            self.ml_engine = JuliaMLEngine.get_instance()
            
            # Only initialize Julia if not already done
            if not self.ml_engine.initialized:
                engine_initialized = self.ml_engine.initialize_julia()
            else:
                print("‚úÖ Using existing initialized Julia ML engine")
                engine_initialized = True
            
            # Disable threaded worker for now due to Julia segfaults
            # TODO: Fix threading issues with Julia
            print("‚ÑπÔ∏è Using direct ML engine mode (threading disabled)")
            self.ml_worker = None
                
            if not engine_initialized:
                print("‚ö†Ô∏è Julia ML engine initialization had issues")
                print("üîß Fallback mode enabled for stability")
                
        except Exception as e:
            print(f"‚ùå Bridge initialization failed: {e}")
            print("üîß Creating safe fallback configuration")
            self.ml_engine = None
            self.ml_worker = None
    
    def _connect_signals(self):
        """Connect worker signals to callback functions"""
        if self.ml_worker:
            self.ml_worker.prediction_ready.connect(self._on_prediction_ready)
            self.ml_worker.risk_calculated.connect(self._on_risk_calculated)
            self.ml_worker.signal_generated.connect(self._on_signal_generated)
            self.ml_worker.error_occurred.connect(self._on_error)
    
    def set_callback(self, event_type: str, callback_func):
        """Set callback function for events"""
        self.callbacks[event_type] = callback_func
    
    def _on_prediction_ready(self, predictions):
        if 'prediction' in self.callbacks:
            self.callbacks['prediction'](predictions)
    
    def _on_risk_calculated(self, risk_score):
        if 'risk' in self.callbacks:
            self.callbacks['risk'](risk_score)
    
    def _on_signal_generated(self, signal):
        if 'signal' in self.callbacks:
            self.callbacks['signal'](signal)
    
    def _on_error(self, error_msg):
        if 'error' in self.callbacks:
            self.callbacks['error'](error_msg)
        else:
            logger.error(f"ML Bridge Error: {error_msg}")
    
    def request_prediction(self, price_data: List[float], periods: int = 5):
        """Request price prediction from Julia ML"""
        try:
            if self.ml_worker:
                self.ml_worker.add_prediction_task(price_data, periods)
                if not self.ml_worker.isRunning():
                    self.ml_worker.start()
            elif self.ml_engine:
                # Direct computation with error handling
                try:
                    predictions = self.ml_engine.predict_price(price_data, periods)
                    if 'prediction' in self.callbacks:
                        self.callbacks['prediction'](predictions)
                except Exception as ml_error:
                    print(f"‚ö†Ô∏è ML Prediction Error: {ml_error}")
                    # Return safe dummy predictions
                    dummy_predictions = [price_data[-1] * (1 + np.random.uniform(-0.02, 0.02)) for _ in range(periods)]
                    if 'prediction' in self.callbacks:
                        self.callbacks['prediction'](dummy_predictions)
            else:
                # Pure fallback - no ML available
                print("üîß Using basic prediction fallback")
                if len(price_data) >= 2:
                    trend = (price_data[-1] - price_data[-2]) / price_data[-2]
                    dummy_predictions = [price_data[-1] * (1 + trend * (i + 1) * 0.1) for i in range(periods)]
                else:
                    dummy_predictions = [price_data[-1]] * periods
                
                if 'prediction' in self.callbacks:
                    self.callbacks['prediction'](dummy_predictions)
                    
        except Exception as e:
            print(f"‚ùå Prediction request error: {e}")
            # Safe fallback for any error
            try:
                if len(price_data) > 0:
                    dummy_predictions = [price_data[-1]] * periods
                    if 'prediction' in self.callbacks:
                        self.callbacks['prediction'](dummy_predictions)
            except Exception as fallback_error:
                print(f"‚ùå Even fallback failed: {fallback_error}")
    
    def request_risk_analysis(self, price_data: List[float]):
        """Request risk analysis from Julia ML"""
        try:
            if self.ml_worker:
                self.ml_worker.add_risk_task(price_data)
                if not self.ml_worker.isRunning():
                    self.ml_worker.start()
            elif self.ml_engine:
                # Direct computation with error handling
                try:
                    risk_score = self.ml_engine.calculate_risk(price_data)
                    if 'risk' in self.callbacks:
                        self.callbacks['risk'](risk_score)
                except Exception as ml_error:
                    print(f"‚ö†Ô∏è ML Risk Analysis Error: {ml_error}")
                    # Return safe dummy risk score
                    dummy_risk = np.random.uniform(0.3, 0.7)  # Medium risk
                    if 'risk' in self.callbacks:
                        self.callbacks['risk'](dummy_risk)
            else:
                # Pure fallback - basic volatility calculation
                print("üîß Using basic risk calculation fallback")
                try:
                    if len(price_data) >= 3:
                        returns = np.diff(price_data) / np.array(price_data[:-1])
                        volatility = np.std(returns)
                        risk_score = min(max(volatility * 5, 0.0), 1.0)  # Normalize to 0-1
                    else:
                        risk_score = 0.5  # Default medium risk
                    
                    if 'risk' in self.callbacks:
                        self.callbacks['risk'](risk_score)
                except Exception as calc_error:
                    print(f"‚ö†Ô∏è Basic risk calculation failed: {calc_error}")
                    if 'risk' in self.callbacks:
                        self.callbacks['risk'](0.5)  # Safe default
                        
        except Exception as e:
            print(f"‚ùå Risk analysis request error: {e}")
            # Safe fallback
            try:
                if 'risk' in self.callbacks:
                    self.callbacks['risk'](0.5)
            except Exception as fallback_error:
                print(f"‚ùå Risk fallback failed: {fallback_error}")
    
    def request_trading_signal(self, price_data: List[float], volume_data: Optional[List[float]] = None):
        """Request trading signal from Julia ML"""
        try:
            if self.ml_worker:
                self.ml_worker.add_signal_task(price_data, volume_data)
                if not self.ml_worker.isRunning():
                    self.ml_worker.start()
            elif self.ml_engine:
                # Direct computation with error handling
                try:
                    signal = self.ml_engine.generate_signal(price_data, volume_data)
                    if 'signal' in self.callbacks:
                        self.callbacks['signal'](signal)
                except Exception as ml_error:
                    print(f"‚ö†Ô∏è ML Signal Generation Error: {ml_error}")
                    # Return safe dummy signal
                    dummy_signals = ["BUY", "SELL", "HOLD"]
                    dummy_signal = np.random.choice(dummy_signals)
                    if 'signal' in self.callbacks:
                        self.callbacks['signal'](dummy_signal)
            else:
                # Pure fallback - simple trend analysis
                print("üîß Using basic signal generation fallback")
                try:
                    if len(price_data) >= 5:
                        recent_avg = np.mean(price_data[-3:])
                        older_avg = np.mean(price_data[-5:-2])
                        
                        if recent_avg > older_avg * 1.02:
                            signal = "BUY"
                        elif recent_avg < older_avg * 0.98:
                            signal = "SELL"
                        else:
                            signal = "HOLD"
                    else:
                        signal = "HOLD"  # Safe default
                    
                    if 'signal' in self.callbacks:
                        self.callbacks['signal'](signal)
                except Exception as calc_error:
                    print(f"‚ö†Ô∏è Basic signal calculation failed: {calc_error}")
                    if 'signal' in self.callbacks:
                        self.callbacks['signal']("HOLD")  # Safe default
                        
        except Exception as e:
            print(f"‚ùå Trading signal request error: {e}")
            # Safe fallback
            try:
                if 'signal' in self.callbacks:
                    self.callbacks['signal']("HOLD")
            except Exception as fallback_error:
                print(f"‚ùå Signal fallback failed: {fallback_error}")
    
    def handle_error(self, error_msg):
        """Handle errors safely"""
        try:
            if 'error' in self.callbacks:
                self.callbacks['error'](error_msg)
            else:
                print(f"Bridge Error: {error_msg}")
        except Exception as e:
            print(f"Error handling error: {e}")
    
    def request_prediction_from_yahoo_data(self, yahoo_data, periods: int = 5):
        """
        Request price prediction from Yahoo Finance data (Person D's format)
        
        Args:
            yahoo_data: Yahoo Finance data in any format (DataFrame, dict, list)
            periods: Number of periods to predict
        """
        price_data = YahooFinanceDataAdapter.extract_prices_from_yahoo_data(yahoo_data)
        if not price_data:
            logger.error("Could not extract price data from Yahoo Finance format")
            if 'error' in self.callbacks:
                self.callbacks['error']("Invalid Yahoo Finance data format")
            return
        
        self.request_prediction(price_data, periods)
    
    def request_risk_from_yahoo_data(self, yahoo_data):
        """Request risk analysis from Yahoo Finance data"""
        price_data = YahooFinanceDataAdapter.extract_prices_from_yahoo_data(yahoo_data)
        if not price_data:
            logger.error("Could not extract price data for risk analysis")
            if 'error' in self.callbacks:
                self.callbacks['error']("Invalid Yahoo Finance data format")
            return
        
        self.request_risk_analysis(price_data)
    
    def request_signal_from_yahoo_data(self, yahoo_data):
        """Request trading signal from Yahoo Finance data"""
        price_data = YahooFinanceDataAdapter.extract_prices_from_yahoo_data(yahoo_data)
        volume_data = YahooFinanceDataAdapter.extract_volume_from_yahoo_data(yahoo_data)
        
        if not price_data:
            logger.error("Could not extract price data for trading signal")
            if 'error' in self.callbacks:
                self.callbacks['error']("Invalid Yahoo Finance data format")
            return
        
        self.request_trading_signal(price_data, volume_data)
    
    def process_crypto_update(self, symbol: str, yahoo_data, analysis_types: List[str] = None):
        """
        Process a crypto update from Person D's Yahoo Finance feed
        
        Args:
            symbol: Crypto symbol (e.g., 'BTC-USD', 'ETH-USD')
            yahoo_data: Yahoo Finance data
            analysis_types: List of analyses to run ['prediction', 'risk', 'signal']
        """
        if analysis_types is None:
            analysis_types = ['prediction', 'risk', 'signal']
        
        logger.info(f"Processing {symbol} update with analyses: {analysis_types}")
        
        # Store current symbol for callbacks
        self.current_symbol = YahooFinanceDataAdapter.get_crypto_symbol_for_julia(symbol)
        
        # Run requested analyses
        if 'prediction' in analysis_types:
            self.request_prediction_from_yahoo_data(yahoo_data)
        
        if 'risk' in analysis_types:
            self.request_risk_from_yahoo_data(yahoo_data)
        
        if 'signal' in analysis_types:
            self.request_signal_from_yahoo_data(yahoo_data)

# Test functions
def test_bridge():
    """Test the Julia-Python bridge"""
    print("üöÄ Testing Julia-Python ML Bridge...")
    
    # Sample price data
    sample_prices = [100, 102, 101, 105, 108, 106, 110, 112, 108, 115]
    
    try:
        bridge = JuliaPythonBridge()
        bridge.initialize()
        
        # Set up callbacks
        def on_prediction(predictions):
            print(f"‚úì Predictions received: {predictions}")
        
        def on_risk(risk_score):
            print(f"‚úì Risk score: {risk_score:.3f}")
        
        def on_signal(signal):
            print(f"‚úì Trading signal: {signal}")
        
        def on_error(error):
            print(f"‚úó Error: {error}")
        
        bridge.set_callback('prediction', on_prediction)
        bridge.set_callback('risk', on_risk)
        bridge.set_callback('signal', on_signal)
        bridge.set_callback('error', on_error)
        
        # Test requests
        bridge.request_prediction(sample_prices, 3)
        bridge.request_risk_analysis(sample_prices)
        bridge.request_trading_signal(sample_prices)
        
        print("‚úì Bridge test completed!")
        
    except Exception as e:
        print(f"‚úó Bridge test failed: {e}")

# Yahoo Finance data adapter
class YahooFinanceDataAdapter:
    """
    Adapter for Yahoo Finance crypto data format
    Works with Person D's data feed
    """
    
    @staticmethod
    def extract_prices_from_yahoo_data(yahoo_data):
        """
        Convert Yahoo Finance data to price list for Julia ML
        
        Args:
            yahoo_data: Can be pandas DataFrame, dict, or list
        Returns:
            List[float]: Price data ready for Julia ML
        """
        try:
            # Handle pandas DataFrame (most common from yfinance)
            if hasattr(yahoo_data, 'Close'):
                return yahoo_data['Close'].tolist()
            elif hasattr(yahoo_data, 'close'):
                return yahoo_data['close'].tolist()
            
            # Handle dictionary format
            if isinstance(yahoo_data, dict):
                if 'Close' in yahoo_data:
                    return list(yahoo_data['Close'].values()) if hasattr(yahoo_data['Close'], 'values') else yahoo_data['Close']
                elif 'close' in yahoo_data:
                    return list(yahoo_data['close'].values()) if hasattr(yahoo_data['close'], 'values') else yahoo_data['close']
                elif 'price' in yahoo_data:
                    return yahoo_data['price'] if isinstance(yahoo_data['price'], list) else [yahoo_data['price']]
            
            # Handle list format (already processed)
            if isinstance(yahoo_data, list):
                return [float(x) for x in yahoo_data]
            
            # Handle single value
            if isinstance(yahoo_data, (int, float)):
                return [float(yahoo_data)]
                
            # Fallback - try to extract any numeric data
            if hasattr(yahoo_data, 'values'):
                flat_values = yahoo_data.values.flatten() if hasattr(yahoo_data.values, 'flatten') else yahoo_data.values
                return [float(x) for x in flat_values if not pd.isna(x)]
                
        except Exception as e:
            logger.warning(f"Could not extract prices from Yahoo data: {e}")
            
        # Ultimate fallback
        return []
    
    @staticmethod
    def extract_volume_from_yahoo_data(yahoo_data):
        """Extract volume data from Yahoo Finance format"""
        try:
            if hasattr(yahoo_data, 'Volume'):
                return yahoo_data['Volume'].tolist()
            elif hasattr(yahoo_data, 'volume'):
                return yahoo_data['volume'].tolist()
            elif isinstance(yahoo_data, dict) and 'Volume' in yahoo_data:
                return list(yahoo_data['Volume'].values()) if hasattr(yahoo_data['Volume'], 'values') else yahoo_data['Volume']
        except Exception as e:
            logger.warning(f"Could not extract volume from Yahoo data: {e}")
        
        return None
    
    @staticmethod
    def get_crypto_symbol_for_julia(symbol: str) -> str:
        """
        Convert crypto symbols to Julia-friendly format
        BTC-USD -> BTC, ETH-USD -> ETH, etc.
        """
        if '-USD' in symbol:
            return symbol.replace('-USD', '')
        elif '-USDT' in symbol:
            return symbol.replace('-USDT', '')
        return symbol

if __name__ == "__main__":
    test_bridge()
